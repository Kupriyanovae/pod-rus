# How to use this widget in event script:
# 1. Add a widget block to the event script:
#		widget = {
#			gui = "POD_event_window_widget_character_selection"
#			container = "foreground_shader_vfx_container"
#		}
# 2. Create a variable list called "event_character_list" on the player character.
#		Put all the characters you want to show up in this variable list.
# 3. Pick one of those characters as the default selection.
#		Save that character as a variable called "selected_event_character" on the player character.
# 4. After closing the event, remove selected_event_character and clear event_character_list from the player.


# This event widget has extensive comments since it's intended as a GUI tutorial.

# A premade vanilla GUI element for creating scrollboxes.
# CK3 lets you define GUI types and templates to make your code more reusable.
# They're a bit like scripted_triggers or scripted_effects in script.
# "scrollbox" is defined in gui\shared\lists.gui
# It comes with some predefined elements that are useful for our purposes.
scrollbox = {
	# The name of the element.
	# GUI elements in Vanilla GUIs often have names, but for custom GUIs it's rarely necessary.
	# Event Widgets are one of the exceptions. Their topmost element needs a name.
	# This will let you use the event widget in event script, by adding it like this:
	# widget = {
	# 	gui = "POD_event_window_widget_character_selection"
	# 	container = "foreground_shader_vfx_container"
	# }
	# This will slot the event widget referred to by "gui" into the container referred to by "container".
	# We use one of the shader containers for this one since they cover the whole event window.
	name = "POD_event_window_widget_character_selection"
	
	# There are many different ways to position GUI elements.
	# Since event windows have a fixed size, it makes sense to give this scrollbox a fixed size too.
	#
	# First, we set an "anchor point" for this scrollbox.
	# The scrollbox is meant to show up on the right side of the window, so we anchor its position to the top right.
	parentanchor = right|top
	# Now, we set its position. Remember, this is relative to the anchor point (the top right of the event window).
	# Note the format of this element. Two numbers inside curly brackets. This is a 2D vector.
	# The first number of a 2D vector refers to a horizontal value (X), with the second one being vertical (Y).
	# In this case, the numbers mean "how far away is this GUI element from the anchor point, in pixels".
	# The X value is negative here to move the scrollbox to the left. Positive values would move it to the right.
	position = { -102 86 }
	# The size of the element. Also a 2D vector.
	# Here, the first number determines width, and the second one determines height.
	size = { 500 436 }
	
	# You can set background images for GUI elements.
	# These will spread out across the entire size of the element.
	background = {
		# You can get really fancy with custom backgrounds, but for now we'll just use a template.
		# Templates are another way to reuse code snippets.
		# This one is defined in gui\shared\backgrounds.gui
		# For a more detailed rundown on types, templates, and blocks, check out Agami's wiki page:
		# https://ck3.paradoxwikis.com/Interface#Templates
		using = Background_Area_ExtraDark
		# Margins add "breathing room" to GUI elements by adding extra distance from their parents.
		# This, too, is a 2D vector, with the X/Y values determining distance in pixels.
		# For this background, positive values mean the background is bigger than the scrollbox.
		# Try setting these to negative values and see what happens.
		margin = { 5 5 }
	}
	
	# GUI elements can have multiple backgrounds.
	# The previous one added a dark texture to the background. This one adds a frame.
	background = {
		using = Background_Frame_Gold
		margin = { 5 5 }
	}
	
	# Blocks are another tool to make GUI code more reusable.
	# The scrollbox type has some properties that we don't need, so we blank those out here.
	# Check out the definitions for these in gui\shared\lists.gui
	blockoverride "scrollbox_margins" {}
	blockoverride "scrollbox_background" {}
	blockoverride "scrollbox_background_fade" {}
	
	# This, however, is a block we do need. It determines what's inside the scrollbox.
	blockoverride "scrollbox_content"
	{
		# Margins can be added to all sorts of GUI elements that are part of a layout.
		# This one adds some vertical "breathing room" to the contents of the scrollbox.
		# Try setting this one to { 0 0 } and you'll see how it looks strange to have no vertical margins.
		margin = { 0 8 }
		
		# Containers are your bread and butter for GUIs. You will be using a lot of these.
		# If you have multiple GUI elements and you want to reposition them all at once, you need containers.
		# There are several types of containers and they each have different effects on the layout of their child elements.
		# We'll use a few different ones in this GUI file.
		# The first one is a fixedgridbox. It's the most rigid type of container.
		# Its child elements get arranged in a vertical grid, with each one having the exact same size.
		# This makes it pretty inflexible, but also very, very light on performance.
		# Perfect if we want to display a list of characters that potentially has many entries.
		fixedgridbox = {
			# Now we need to set the size of the child elements.
			# addcolumn to set the width, and addrow to set the height.
			# By default, a fixedgridbox acts as a vertical list, which suits us just fine.
			# flipdirection = yes would turn it into a horizontal list.
			addcolumn = 500
			addrow = 90
			
			# Here we go. Our first chained datafunction. These are the same ones used in localization.
			# Datafunctions are always wrapped in square brackets.
			# In GUI files, you also need to wrap them in quotation marks.
			#
			# But first, what is this one used for? What is a datamodel?
			# Datamodels are used whenever you want to display a list of something.
			# For example, GetKnights would return all the knights of a character.
			# If you then use GetKnights as a datamodel for a conainer, you can then display a GUI element for each knight.
			# Whether it's just their name, their portrait, or a more complicated combination of elements.
			#
			# Now let's go through the datafunction calls one by one.
			#
			# GetPlayer returns the character you're currently playing.
			# This type of function is called a "promote".
			# Promotes are datafunctions that return some kind of game object: a character, faith, culture, and the like.
			# You can chain promotes together with a period, just like how you can chain scope switches in script.
			# GetPlayer is also a global promote, meaning you can use it anywhere, in any context, which makes it very handy.
			#
			# MakeScope is another promote. This one is a bit more complicated to explain.
			# In script, everything is a "scope". In GUI, that is not the case.
			# GUI has separate data types for anything that would be a "scope" in script: Character, DynastyHouse, Faith, etc.
			# Most datafunctions only work if you give them these specific data types as input.
			# However, some instead take the generic Scope type as input, like those having to do with script variables and lists.
			# We want to access a variable list on this character, so we have to convert it to a Scope first, with MakeScope.
			#
			# Finally, GetList() returns all elements from a variable list.
			datamodel = "[GetPlayer.MakeScope.GetList('event_character_list')]"
			
			# This is where the magic happens.
			# When you define a datamodel for a container, you also need to define an "item".
			# For each element in the datamodel, the GUI will automatically create a new copy of this item.
			# So to use the earlier example, if we had used GetKnights as the datamodel, there'd be an item for each knight.
			# In our case, since we access the event_character_list variable list, an item gets created for each of its elements.
			#
			# One thing I didn't mention before is that some containers strictly require a datamodel.
			# fixedgridbox is one of them. So if it didn't didn't have a datamodel and an item, the game would throw an error.
			item = {
				# An item can have only one child element.
				# If you want more than one, you have to put them in a container.
				# Here we use a widget, pretty much the simplest container there is.
				# By default, it has no size, and it does nothing to help you position its child elements.
				# You could use widgets to build entire GUIs, but you'd have to set the size and position of each child manually. Boring.
				# Here we use it only because its size is static and it's light on performance, which makes it perfect for our fixedgridbox.
				widget = {
					# Note that this is the same size as the addcolumn and addrow properties for the fixedgridbox.
					size = { 500 90 }
					
					# Now we're nesting another container in the widget.
					# hbox and vbox are two types of containers that resize automatically based on their children.
					# They're powerful and simple to use. I love them. I'd use them everywhere if I could.
					# An hbox arranges its children in a horizontal line and centers them vertically.
					# That means no need to push individual child elements around on a pixel-by-pixel basis.
					hbox = {
						# How much space there should be between each child element of the hbox.
						spacing = 6
						
						# Spacers are invisible and don't do anything except, well, add space.
						# They're particularly useful for hbox/vbox containers.
						# Try commenting out this line and see what happens.
						spacer = { size = { 12 0 } }
						
						# Our first button.
						# This one is a premade type, from gui\shared\buttons.gui
						# It looks like a checkbox and we'll use it to show which character in the list is currently selected.
						button_checkbox = {
							# You know the drill by now. 2D vector with width and height.
							# This is a bit bigger than the default checkbox.
							# Try commenting out this line to see the default size. Looks a bit small next to the portrait, doesn't it?
							size = { 40 40 }
							
							# A simple tooltip. The text on the right-hand side is a localization key.
							# You can get much fancier with tooltips and put custom GUI inside them, but sometimes, simple is best.
							tooltip = "POD_select_scoped_char"
							# This template makes the tooltip show up to the left of the button.
							using = tooltip_ws
							
							# Now for what's probably the most complicated line in this GUI file.
							# Unfortunately, datafunction calls have to be uninterrupted.
							# All in one line, no whitespace, no room for comments.
							# This can lead to some intimidatingly long function calls.
							#
							# No fear. We will look at each part of this line, one by one.
							#
							# Unsurprisingly, onclick determines what happens when you click this button. Only buttons have this property.
							#
							# Now for the datafunction itself.
							# When we click the button, we would like to select this character, and save it as a variable on the player.
							# There is no datafunction for setting variables.
							# Nor for a lot of other things that are easy to do in script.
							# But that's no problem, because we can use Scripted GUIs.
							#
							# Scripted GUIs (or SGUIs for short) are basically your bridge between GUI and script.
							# They are defined in common\scripted_guis and PoD already has a lot of examples of them.
							# SGUIs let you set script triggers that you can check from GUI, or effects that run when you click a button.
							# This one, POD_character_list_select, is defined in common\scripted_guis\POD_gui_tutorial.txt
							# But before we can use it, we need to pass the correct data to it. Hence the long datafunction chain.
							#
							# The first part, GetScriptedGui(), is a promote. We use it to access the SGUI by its name.
							# Then we follow it up with Execute() to run the effect block of the SGUI.
							# If we had defined triggers in the SGUI, we'd access them with IsValid() or IsShown() instead.
							#
							# Inside the brackets of Execute() we need to set up all the scopes the SGUI needs.
							# To do this, we need another chain of datafunctions.
							# Yes, you can nest datafunctions. Sometimes you might have to nest multiple layers.
							# This can get crazy. The example here is pretty mild, all things considered.
							# This is where Notepad++ can help, by showing you matching brackets.
							# Or it might help you visualize the nested layers by looking at them separately.
							#
							# So, layer #1:
							#	GetScriptedGui('POD_character_list_select').Execute(  )
							# Layer #2, inside the Execute(  ):
							#	GuiScope.SetRoot(GetPlayer.MakeScope).AddScope('selection',Scope.Char.MakeScope).End
							# We already looked at layer #1, now let's look at layer #2.
							#
							# GuiScope basically creates a blank slate for running scripts on.
							# This is similar to clicking a decision or doing a character interaction ingame.
							# You know how when you save a scope with save_scope_as, they get inherited by future events in that chain?
							# This is how you start such a chain.
							#
							# SetRoot() sets the root for the SGUI.
							# Since we set the scope type to character in the SGUI, we need to pass a character here.
							# But! We can't just use GetPlayer, because script and GUI use different data types, remember?
							# We need to translate it into a scope so that script can understand it. Hence: GetPlayer.MakeScope
							#
							# AddScope() is sort of like save_scope_as, but for GUI.
							# This datafunction has two arguments, separated by commas.
							# The first one is the name the scope will be saved as.
							# We save our scope as 'selection', meaning we can access it in the SGUI with scope:selection
							# The second argument is the content of that scope.
							# But to properly explain that part, I first need to explain datacontexts.
							#
							# So to recap: Earlier in this file, we created a datamodel.
							# The datamodel contained a variable list. In this case, a list full of characters.
							# For each entry in the datamodel, the GUI created an item.
							# But how do we access these entries?
							# By using their data type as a promote.
							#
							# This is easier to explain if we use the GetKnights datamodel as an example.
							# GetKnights returns a list of characters.
							# Remember, GUI uses a different set of data types than script. In script, everything is a scope.
							# In GUI, a character has the Character data type.
							# So within the item of a container with the GetKnights datamodel, "Character" returns a knight.
							# You could, say, have a line of text set to "[Character.GetName]", and it would display each knight's name.
							#
							# That example was simpler because GetKnights uses a GUI data type.
							# Our data model was built with GetList(), a variable list defined in script.
							# You can probably see where this is going.
							# The relevant data type isn't Character, but Scope. So we use Scope as a promote.
							#
							# Earlier, we used GetPlayer as a promote, then used MakeScope to turn the Character into a Scope.
							# Basically turning a GUI data type into a format that script can understand.
							# Now we do it in reverse.
							# We get the current entry of the datamodel with Scope, then turn it into a Character.
							# Like this: Scope.Char
							# But then... since we have to use it as input for an SGUI, we need to turn it back into a Scope.
							# Scope.Char.MakeScope
							# Silly? Maybe. I don't know. But it works.
							#
							# Finally, we have to end the nested datafunction chain with an .End to prevent memory leaks.
							# At least I think it's because of memory leaks. Don't ask me.
							onclick = "[GetScriptedGui('POD_character_list_select').Execute(GuiScope.SetRoot(GetPlayer.MakeScope).AddScope('selection',Scope.Char.MakeScope).End)]"
							
							# Phew. That was something. How about a shorter datafunction chain?
							# Some datafunctions are basically like scripted_triggers. They can return true or false.
							# This one determines whether the checkbox is ticked or not. True means ticked, false means unticked.
							#
							# We want the checkbox to be ticked if the character in this datamodel item is the one that's selected.
							# We already know how to access the character from the item: Scope.Char
							#
							# The selected character is saved on the player, on a variable called selected_event_character.
							# We can get a saved variable with the Var() promote, but it only works on scopes.
							# So: GetPlayer to access the player. MakeScope to convert to a scope. Var() to access the variable.
							# Since Var() returns a Scope, we need to convert it back to a Character, with .Char
							#
							# Finally, we use ObjectsEqual() to compare the two characters.
							# If the two characters are the same, return true. If not, return false.
							checked = "[ObjectsEqual( Scope.Char, GetPlayer.MakeScope.Var('selected_event_character').Char )]"
						}
						
						# Another premade vanilla type. This one shows a character's portrait.
						# Its definition is in gui\shared\portraits.gui
						# The vanilla file for this one says "only use if you really, really have to".
						# But it's used pretty much everywhere in vanilla GUI anyway. Dunno what's up with that.
						# Anyway, this type is simple since you can use it pretty much as is.
						portrait_head_small = {
							# The only thing you need to do is pass the datacontext.
							# Like in the other examples earlier, GUI understands Character, script understands Scope.
							# All the vanilla portrait elements expect a Character to be present.
							# Setting a datacontext like this essentially acts like a translator.
							# If we used a datamodel that returns Characters, like GetKnights, this line wouldn't be necessary.
							datacontext = "[Scope.Char]"
						}
						
						# Another button. This one will contain the character's name, relation, and stats.
						# I'm using the event button since its frame is nice and minimalistic.
						# Try changing it to button_normal or button_standard.
						button_event_standard = {
							# Layout policies are a powerful tools for positioning GUI elements inside a hbox or vbox.
							# This one will tell the button to take up all the available space in the container.
							# Not just the container, but the parent's container too.
							# So the hbox will grow to the entire width of the parent widget (500 pixels).
							# If you want to learn more about layout policies, check out Agami's wiki page:
							# https://ck3.paradoxwikis.com/Interface#hbox/vbox
							layoutpolicy_horizontal = expanding
							
							# Setting the height of this button to 80 pixels.
							# The X value of this 2D vector is ignored because of the horizontal layout policy we just set.
							size = { 0 80 }
							
							# Same datafunction for onclick as the one for the above checkbox.
							onclick = "[GetScriptedGui('POD_character_list_select').Execute(GuiScope.SetRoot(GetPlayer.MakeScope).AddScope('selection',Scope.Char.MakeScope).End)]"
							
							# Same datafunction as the checked property for the above checkbox.
							# This time, if the datafunction returns true, the button gets highlighted.
							down = "[ObjectsEqual( Scope.Char, GetPlayer.MakeScope.Var('selected_event_character').Char )]"
							
							# The default graphics for the highlighted button were a bit too intense for my liking.
							# You can see the button texture in gfx\interface\buttons\button_event.dds
							# I won't get into it too much here since this tutorial is pretty long as is.
							# But you can try commenting out this line, or setting it to different numbers, to see what happens.
							downframe = 5
							
							# Same tooltip as the checkbox.
							tooltip = "POD_select_scoped_char"
							# Tooltip to the right so it doesn't cover the button.
							using = tooltip_es
							
							# You can change the click sound of buttons, if you want.
							# It's a small thing, but it can make your GUIs feel more satisfying, or consistent.
							# In this case, I'm setting the click sound to the same one as the button_checkbox one.
							clicksound = "event:/SFX/UI/Generic/sfx_ui_generic_confirm"
							
							# Now inside the button, we want to arrange a few GUI elements vertically.
							# The name of the character, their relation to the player, and their stats.
							#
							# For this, we will use a vbox container.
							# A vbox arranges its children in a vertical line and centers them horizontally.
							# So like an hbox, but in the other direction.
							vbox = {
								# This is an expander.
								# Expanders will take up the remaining space of this vbox.
								# We will use two expanders, one at the beginning and one at the end, to center the contents vertically.
								expand = {}
								
								# A single line of text.
								# If you want to display very long lines with automatic line breaks, there's also text_multi.
								text_single = {
									# The actual text.
									# You can put a localization key or a datafunction here.
									#
									# To recap:
									# Scope refers to the scope from the current datacontext.
									# Char converts that scope to a Character.
									# GetNameNoTooltip returns the full name of that character as a string.
									#
									# There are many different datafunctions to display a character's name.
									# Try these:
									#	GetFirstName
									#	GetFirstNameNicknamed
									#	GetTitleAsName
									# Adding NoTooltip ensures the name gets displayed as plain text, with no formatting or tooltip.
									text = "[Scope.Char.GetNameNoTooltip]"
									
									# We can also set some default formatting for the text so we don't have to do it in localization.
									# Since the character's name is important, I'm bolding it.
									#
									# I'm also adding a black glowing outline, to make the text pop from the background.
									# CK3 only rarely adds outlines to text. I'm not sure why.
									# These stylistic choices differ from game to game. Vicky 3 has outlines everywhere.
									# Do you want your GUIs to be consistent with vanilla ones, or put your own spin on them?
									# That is for you to decide.
									default_format = "#bold;glow_color:{0,0,0,1}"
									
									# Setting a maximum width for lines of text is always a good idea.
									# Some characters in PoD can have really long names.
									# Since the Y value of the maximumsize is set to -1, it will be ignored. Only width matters.
									maximumsize = { 288 -1 }
								}
								
								# Another line of text.
								text_single = {
									# You know the drill by now.
									# GetRelationToString() displays something like "Your Lover and Knight".
									# It's the same datafunction used by the character window.
									# We pass GetPlayer since it's the relation to us that we care about.
									text = "[Scope.Char.GetRelationToString(GetPlayer)]"
									
									# Using a black glowing outline again.
									# Also #low, which dims the text to a darker gray.
									# The most important thing with GUI isn't to make it look fancy, but to make it easy to read.
									# Visual hierarchy is one of the ways to accomplish that.
									# The most important part of this button (the name) is bold and highly visible.
									# The relation is less important, so it has less contrast to make it less distracting.
									default_format = "#low;glow_color:{0,0,0,1}"
									
									# You can also set replacements for text formatting.
									# This is mostly used for GUI elements with light backgrounds, to turn the text black instead of white.
									# In this case, I'm using it to make the relation text even less distracting.
									# Some relations (like "Knight") link to encyclopedia entries, which would turn the text light blue.
									# Or they might link to characters ("Duke Camilla's Spymaster"), turning the text white.
									# These overrides ensure that the text is always dimmed.
									format_override = { E low }
									format_override = { high low }
									
									# GetRelationToString() can return some really long lines of text, so I'm setting a maximum width here too.
									maximumsize = { 288 -1 }
								}
								
								# Tiny bit of vertical spacing.
								# I find that there's always too little space left under text elements.
								# A bit of breathing room can go a long way in making a GUI look clean.
								spacer = { size = { 0 2 } }
								
								# This is a vanilla GUI type for showing a character's stats.
								# The definition is in gui\shared\lists.gui
								# We actually edit this one in PoD to make prowess show up as well.
								hbox_skills_grid_character_model = {
									# Just like with the portrait, we need to pass a Character datacontext to this one too.
									#
									# There's actually a better way to do this.
									# datacontexts are inherited by child elements.
									# So we could've added this datacontext to the hbox or widget containers instead.
									# That way we wouldn't have to write it twice.
									# But doing it this way made the tutorial flow better, so.
									datacontext = "[Scope.Char]"
								}
								
								# Another expander, like the one at the beginning of the vbox.
								# Since there are two expanders, each one will take half of the remaining space.
								# This will nicely center all the children of the vbox vertically.
								expand = {}
							}
						}
						
						# One last spacer for the hbox to make sure the button doesn't overlap the scrollbar.
						spacer = { size = { 12 0 } }
					}
				}
			}
		}
	}
	
	# One last block from the scrollbox type.
	# This one lets you display a line of text if the datamodel is empty. A useful UX measure.
	blockoverride "scrollbox_empty"
	{
		# This datafunction uses a datamodel as input and returns true if it's empty.
		# We input the same datamodel that we used for our fixedgridbox earlier.
		visible = "[IsDataModelEmpty(GetPlayer.MakeScope.GetList('event_character_list'))]"
		# The text simply refers to a localization key.
		text = "POD_character_select_empty"
		default_format = "#weak;glow_color:{0,0,0,1}"
	}
}

# I'd like to encourage you to try changing things around in this file to see what happens.
# GUI has little documentation, so experimenting is the best way to learn.
# Luckily GUI files hot-reload in Debug Mode, so any changes are easy to test.
# Just save the file and the changes will show up in your game.
# For event widgets specifically, you might have to reload the event window to make changes show up.